/*
Semaphore API

Semaphore API provides endpoints for managing and interacting with the Semaphore UI. This documentation outlines the available operations and data models. 

API version: 2.13.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package semaphore

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ProjectAPI interface {

	/*
	ProjectProjectIdBackupGet Backup A Project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdBackupGetRequest
	*/
	ProjectProjectIdBackupGet(ctx context.Context, projectId int32) ApiProjectProjectIdBackupGetRequest

	// ProjectProjectIdBackupGetExecute executes the request
	//  @return ProjectBackup
	ProjectProjectIdBackupGetExecute(r ApiProjectProjectIdBackupGetRequest) (*ProjectBackup, *http.Response, error)

	/*
	ProjectProjectIdDelete Delete project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdDeleteRequest
	*/
	ProjectProjectIdDelete(ctx context.Context, projectId int32) ApiProjectProjectIdDeleteRequest

	// ProjectProjectIdDeleteExecute executes the request
	ProjectProjectIdDeleteExecute(r ApiProjectProjectIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdEnvironmentEnvironmentIdDelete Removes environment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param environmentId environment ID
	@return ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest
	*/
	ProjectProjectIdEnvironmentEnvironmentIdDelete(ctx context.Context, projectId int32, environmentId int32) ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest

	// ProjectProjectIdEnvironmentEnvironmentIdDeleteExecute executes the request
	ProjectProjectIdEnvironmentEnvironmentIdDeleteExecute(r ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdEnvironmentEnvironmentIdGet Get environment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param environmentId environment ID
	@return ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest
	*/
	ProjectProjectIdEnvironmentEnvironmentIdGet(ctx context.Context, projectId int32, environmentId int32) ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest

	// ProjectProjectIdEnvironmentEnvironmentIdGetExecute executes the request
	//  @return Environment
	ProjectProjectIdEnvironmentEnvironmentIdGetExecute(r ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest) (*Environment, *http.Response, error)

	/*
	ProjectProjectIdEnvironmentEnvironmentIdPut Update environment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param environmentId environment ID
	@return ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest
	*/
	ProjectProjectIdEnvironmentEnvironmentIdPut(ctx context.Context, projectId int32, environmentId int32) ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest

	// ProjectProjectIdEnvironmentEnvironmentIdPutExecute executes the request
	ProjectProjectIdEnvironmentEnvironmentIdPutExecute(r ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest) (*http.Response, error)

	/*
	ProjectProjectIdEnvironmentGet Get environment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdEnvironmentGetRequest
	*/
	ProjectProjectIdEnvironmentGet(ctx context.Context, projectId int32) ApiProjectProjectIdEnvironmentGetRequest

	// ProjectProjectIdEnvironmentGetExecute executes the request
	//  @return []Environment
	ProjectProjectIdEnvironmentGetExecute(r ApiProjectProjectIdEnvironmentGetRequest) ([]Environment, *http.Response, error)

	/*
	ProjectProjectIdEnvironmentPost Add environment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdEnvironmentPostRequest
	*/
	ProjectProjectIdEnvironmentPost(ctx context.Context, projectId int32) ApiProjectProjectIdEnvironmentPostRequest

	// ProjectProjectIdEnvironmentPostExecute executes the request
	//  @return Environment
	ProjectProjectIdEnvironmentPostExecute(r ApiProjectProjectIdEnvironmentPostRequest) (*Environment, *http.Response, error)

	/*
	ProjectProjectIdEventsGet Get Events related to this project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdEventsGetRequest
	*/
	ProjectProjectIdEventsGet(ctx context.Context, projectId int32) ApiProjectProjectIdEventsGetRequest

	// ProjectProjectIdEventsGetExecute executes the request
	//  @return []Event
	ProjectProjectIdEventsGetExecute(r ApiProjectProjectIdEventsGetRequest) ([]Event, *http.Response, error)

	/*
	ProjectProjectIdGet Fetch project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdGetRequest
	*/
	ProjectProjectIdGet(ctx context.Context, projectId int32) ApiProjectProjectIdGetRequest

	// ProjectProjectIdGetExecute executes the request
	//  @return Project
	ProjectProjectIdGetExecute(r ApiProjectProjectIdGetRequest) (*Project, *http.Response, error)

	/*
	ProjectProjectIdIntegrationsGet get all integrations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdIntegrationsGetRequest
	*/
	ProjectProjectIdIntegrationsGet(ctx context.Context, projectId int32) ApiProjectProjectIdIntegrationsGetRequest

	// ProjectProjectIdIntegrationsGetExecute executes the request
	//  @return []Integration
	ProjectProjectIdIntegrationsGetExecute(r ApiProjectProjectIdIntegrationsGetRequest) ([]Integration, *http.Response, error)

	/*
	ProjectProjectIdIntegrationsIntegrationIdDelete Remove integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param integrationId integration ID
	@return ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest
	*/
	ProjectProjectIdIntegrationsIntegrationIdDelete(ctx context.Context, projectId int32, integrationId int32) ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest

	// ProjectProjectIdIntegrationsIntegrationIdDeleteExecute executes the request
	ProjectProjectIdIntegrationsIntegrationIdDeleteExecute(r ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdIntegrationsIntegrationIdMatchersPost Add Integration Matcher

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param integrationId integration ID
	@return ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest
	*/
	ProjectProjectIdIntegrationsIntegrationIdMatchersPost(ctx context.Context, projectId int32, integrationId int32) ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest

	// ProjectProjectIdIntegrationsIntegrationIdMatchersPostExecute executes the request
	ProjectProjectIdIntegrationsIntegrationIdMatchersPostExecute(r ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest) (*http.Response, error)

	/*
	ProjectProjectIdIntegrationsIntegrationIdPut Update Integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param integrationId integration ID
	@return ApiProjectProjectIdIntegrationsIntegrationIdPutRequest
	*/
	ProjectProjectIdIntegrationsIntegrationIdPut(ctx context.Context, projectId int32, integrationId int32) ApiProjectProjectIdIntegrationsIntegrationIdPutRequest

	// ProjectProjectIdIntegrationsIntegrationIdPutExecute executes the request
	ProjectProjectIdIntegrationsIntegrationIdPutExecute(r ApiProjectProjectIdIntegrationsIntegrationIdPutRequest) (*http.Response, error)

	/*
	ProjectProjectIdIntegrationsIntegrationIdValuesPost Add Integration Extracted Value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param integrationId integration ID
	@return ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest
	*/
	ProjectProjectIdIntegrationsIntegrationIdValuesPost(ctx context.Context, projectId int32, integrationId int32) ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest

	// ProjectProjectIdIntegrationsIntegrationIdValuesPostExecute executes the request
	ProjectProjectIdIntegrationsIntegrationIdValuesPostExecute(r ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest) (*http.Response, error)

	/*
	ProjectProjectIdIntegrationsPost create a new integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdIntegrationsPostRequest
	*/
	ProjectProjectIdIntegrationsPost(ctx context.Context, projectId int32) ApiProjectProjectIdIntegrationsPostRequest

	// ProjectProjectIdIntegrationsPostExecute executes the request
	//  @return Integration
	ProjectProjectIdIntegrationsPostExecute(r ApiProjectProjectIdIntegrationsPostRequest) (*Integration, *http.Response, error)

	/*
	ProjectProjectIdInventoryGet Get inventory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdInventoryGetRequest
	*/
	ProjectProjectIdInventoryGet(ctx context.Context, projectId int32) ApiProjectProjectIdInventoryGetRequest

	// ProjectProjectIdInventoryGetExecute executes the request
	//  @return []Inventory
	ProjectProjectIdInventoryGetExecute(r ApiProjectProjectIdInventoryGetRequest) ([]Inventory, *http.Response, error)

	/*
	ProjectProjectIdInventoryInventoryIdDelete Removes inventory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param inventoryId inventory ID
	@return ApiProjectProjectIdInventoryInventoryIdDeleteRequest
	*/
	ProjectProjectIdInventoryInventoryIdDelete(ctx context.Context, projectId int32, inventoryId int32) ApiProjectProjectIdInventoryInventoryIdDeleteRequest

	// ProjectProjectIdInventoryInventoryIdDeleteExecute executes the request
	ProjectProjectIdInventoryInventoryIdDeleteExecute(r ApiProjectProjectIdInventoryInventoryIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdInventoryInventoryIdGet Get inventory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param inventoryId inventory ID
	@return ApiProjectProjectIdInventoryInventoryIdGetRequest
	*/
	ProjectProjectIdInventoryInventoryIdGet(ctx context.Context, projectId int32, inventoryId int32) ApiProjectProjectIdInventoryInventoryIdGetRequest

	// ProjectProjectIdInventoryInventoryIdGetExecute executes the request
	//  @return Inventory
	ProjectProjectIdInventoryInventoryIdGetExecute(r ApiProjectProjectIdInventoryInventoryIdGetRequest) (*Inventory, *http.Response, error)

	/*
	ProjectProjectIdInventoryInventoryIdPut Updates inventory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param inventoryId inventory ID
	@return ApiProjectProjectIdInventoryInventoryIdPutRequest
	*/
	ProjectProjectIdInventoryInventoryIdPut(ctx context.Context, projectId int32, inventoryId int32) ApiProjectProjectIdInventoryInventoryIdPutRequest

	// ProjectProjectIdInventoryInventoryIdPutExecute executes the request
	ProjectProjectIdInventoryInventoryIdPutExecute(r ApiProjectProjectIdInventoryInventoryIdPutRequest) (*http.Response, error)

	/*
	ProjectProjectIdInventoryPost create inventory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdInventoryPostRequest
	*/
	ProjectProjectIdInventoryPost(ctx context.Context, projectId int32) ApiProjectProjectIdInventoryPostRequest

	// ProjectProjectIdInventoryPostExecute executes the request
	//  @return Inventory
	ProjectProjectIdInventoryPostExecute(r ApiProjectProjectIdInventoryPostRequest) (*Inventory, *http.Response, error)

	/*
	ProjectProjectIdKeysGet Get access keys linked to project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdKeysGetRequest
	*/
	ProjectProjectIdKeysGet(ctx context.Context, projectId int32) ApiProjectProjectIdKeysGetRequest

	// ProjectProjectIdKeysGetExecute executes the request
	//  @return []AccessKey
	ProjectProjectIdKeysGetExecute(r ApiProjectProjectIdKeysGetRequest) ([]AccessKey, *http.Response, error)

	/*
	ProjectProjectIdKeysKeyIdDelete Removes access key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param keyId key ID
	@return ApiProjectProjectIdKeysKeyIdDeleteRequest
	*/
	ProjectProjectIdKeysKeyIdDelete(ctx context.Context, projectId int32, keyId int32) ApiProjectProjectIdKeysKeyIdDeleteRequest

	// ProjectProjectIdKeysKeyIdDeleteExecute executes the request
	ProjectProjectIdKeysKeyIdDeleteExecute(r ApiProjectProjectIdKeysKeyIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdKeysKeyIdPut Updates access key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param keyId key ID
	@return ApiProjectProjectIdKeysKeyIdPutRequest
	*/
	ProjectProjectIdKeysKeyIdPut(ctx context.Context, projectId int32, keyId int32) ApiProjectProjectIdKeysKeyIdPutRequest

	// ProjectProjectIdKeysKeyIdPutExecute executes the request
	ProjectProjectIdKeysKeyIdPutExecute(r ApiProjectProjectIdKeysKeyIdPutRequest) (*http.Response, error)

	/*
	ProjectProjectIdKeysPost Add access key

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdKeysPostRequest
	*/
	ProjectProjectIdKeysPost(ctx context.Context, projectId int32) ApiProjectProjectIdKeysPostRequest

	// ProjectProjectIdKeysPostExecute executes the request
	//  @return AccessKey
	ProjectProjectIdKeysPostExecute(r ApiProjectProjectIdKeysPostRequest) (*AccessKey, *http.Response, error)

	/*
	ProjectProjectIdPut Update project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdPutRequest
	*/
	ProjectProjectIdPut(ctx context.Context, projectId int32) ApiProjectProjectIdPutRequest

	// ProjectProjectIdPutExecute executes the request
	ProjectProjectIdPutExecute(r ApiProjectProjectIdPutRequest) (*http.Response, error)

	/*
	ProjectProjectIdRepositoriesGet Get repositories

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdRepositoriesGetRequest
	*/
	ProjectProjectIdRepositoriesGet(ctx context.Context, projectId int32) ApiProjectProjectIdRepositoriesGetRequest

	// ProjectProjectIdRepositoriesGetExecute executes the request
	//  @return []Repository
	ProjectProjectIdRepositoriesGetExecute(r ApiProjectProjectIdRepositoriesGetRequest) ([]Repository, *http.Response, error)

	/*
	ProjectProjectIdRepositoriesPost Add repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdRepositoriesPostRequest
	*/
	ProjectProjectIdRepositoriesPost(ctx context.Context, projectId int32) ApiProjectProjectIdRepositoriesPostRequest

	// ProjectProjectIdRepositoriesPostExecute executes the request
	//  @return Repository
	ProjectProjectIdRepositoriesPostExecute(r ApiProjectProjectIdRepositoriesPostRequest) (*Repository, *http.Response, error)

	/*
	ProjectProjectIdRepositoriesRepositoryIdDelete Removes repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param repositoryId repository ID
	@return ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest
	*/
	ProjectProjectIdRepositoriesRepositoryIdDelete(ctx context.Context, projectId int32, repositoryId int32) ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest

	// ProjectProjectIdRepositoriesRepositoryIdDeleteExecute executes the request
	ProjectProjectIdRepositoriesRepositoryIdDeleteExecute(r ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdRepositoriesRepositoryIdGet Get repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param repositoryId repository ID
	@return ApiProjectProjectIdRepositoriesRepositoryIdGetRequest
	*/
	ProjectProjectIdRepositoriesRepositoryIdGet(ctx context.Context, projectId int32, repositoryId int32) ApiProjectProjectIdRepositoriesRepositoryIdGetRequest

	// ProjectProjectIdRepositoriesRepositoryIdGetExecute executes the request
	//  @return Repository
	ProjectProjectIdRepositoriesRepositoryIdGetExecute(r ApiProjectProjectIdRepositoriesRepositoryIdGetRequest) (*Repository, *http.Response, error)

	/*
	ProjectProjectIdRepositoriesRepositoryIdPut Updates repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param repositoryId repository ID
	@return ApiProjectProjectIdRepositoriesRepositoryIdPutRequest
	*/
	ProjectProjectIdRepositoriesRepositoryIdPut(ctx context.Context, projectId int32, repositoryId int32) ApiProjectProjectIdRepositoriesRepositoryIdPutRequest

	// ProjectProjectIdRepositoriesRepositoryIdPutExecute executes the request
	ProjectProjectIdRepositoriesRepositoryIdPutExecute(r ApiProjectProjectIdRepositoriesRepositoryIdPutRequest) (*http.Response, error)

	/*
	ProjectProjectIdRoleGet Fetch permissions of the current user for project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdRoleGetRequest
	*/
	ProjectProjectIdRoleGet(ctx context.Context, projectId int32) ApiProjectProjectIdRoleGetRequest

	// ProjectProjectIdRoleGetExecute executes the request
	//  @return ProjectProjectIdRoleGet200Response
	ProjectProjectIdRoleGetExecute(r ApiProjectProjectIdRoleGetRequest) (*ProjectProjectIdRoleGet200Response, *http.Response, error)

	/*
	ProjectProjectIdTasksGet Get Tasks related to current project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdTasksGetRequest
	*/
	ProjectProjectIdTasksGet(ctx context.Context, projectId int32) ApiProjectProjectIdTasksGetRequest

	// ProjectProjectIdTasksGetExecute executes the request
	//  @return []Task
	ProjectProjectIdTasksGetExecute(r ApiProjectProjectIdTasksGetRequest) ([]Task, *http.Response, error)

	/*
	ProjectProjectIdTasksLastGet Get last 200 Tasks related to current project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdTasksLastGetRequest
	*/
	ProjectProjectIdTasksLastGet(ctx context.Context, projectId int32) ApiProjectProjectIdTasksLastGetRequest

	// ProjectProjectIdTasksLastGetExecute executes the request
	//  @return []Task
	ProjectProjectIdTasksLastGetExecute(r ApiProjectProjectIdTasksLastGetRequest) ([]Task, *http.Response, error)

	/*
	ProjectProjectIdTasksPost Starts a job

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdTasksPostRequest
	*/
	ProjectProjectIdTasksPost(ctx context.Context, projectId int32) ApiProjectProjectIdTasksPostRequest

	// ProjectProjectIdTasksPostExecute executes the request
	//  @return Task
	ProjectProjectIdTasksPostExecute(r ApiProjectProjectIdTasksPostRequest) (*Task, *http.Response, error)

	/*
	ProjectProjectIdTasksTaskIdDelete Deletes task (including output)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param taskId task ID
	@return ApiProjectProjectIdTasksTaskIdDeleteRequest
	*/
	ProjectProjectIdTasksTaskIdDelete(ctx context.Context, projectId int32, taskId int32) ApiProjectProjectIdTasksTaskIdDeleteRequest

	// ProjectProjectIdTasksTaskIdDeleteExecute executes the request
	ProjectProjectIdTasksTaskIdDeleteExecute(r ApiProjectProjectIdTasksTaskIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdTasksTaskIdGet Get a single task

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param taskId task ID
	@return ApiProjectProjectIdTasksTaskIdGetRequest
	*/
	ProjectProjectIdTasksTaskIdGet(ctx context.Context, projectId int32, taskId int32) ApiProjectProjectIdTasksTaskIdGetRequest

	// ProjectProjectIdTasksTaskIdGetExecute executes the request
	//  @return Task
	ProjectProjectIdTasksTaskIdGetExecute(r ApiProjectProjectIdTasksTaskIdGetRequest) (*Task, *http.Response, error)

	/*
	ProjectProjectIdTasksTaskIdOutputGet Get task output

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param taskId task ID
	@return ApiProjectProjectIdTasksTaskIdOutputGetRequest
	*/
	ProjectProjectIdTasksTaskIdOutputGet(ctx context.Context, projectId int32, taskId int32) ApiProjectProjectIdTasksTaskIdOutputGetRequest

	// ProjectProjectIdTasksTaskIdOutputGetExecute executes the request
	//  @return []TaskOutput
	ProjectProjectIdTasksTaskIdOutputGetExecute(r ApiProjectProjectIdTasksTaskIdOutputGetRequest) ([]TaskOutput, *http.Response, error)

	/*
	ProjectProjectIdTasksTaskIdStopPost Stop a job

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param taskId task ID
	@return ApiProjectProjectIdTasksTaskIdStopPostRequest
	*/
	ProjectProjectIdTasksTaskIdStopPost(ctx context.Context, projectId int32, taskId int32) ApiProjectProjectIdTasksTaskIdStopPostRequest

	// ProjectProjectIdTasksTaskIdStopPostExecute executes the request
	ProjectProjectIdTasksTaskIdStopPostExecute(r ApiProjectProjectIdTasksTaskIdStopPostRequest) (*http.Response, error)

	/*
	ProjectProjectIdTemplatesGet Get template

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdTemplatesGetRequest
	*/
	ProjectProjectIdTemplatesGet(ctx context.Context, projectId int32) ApiProjectProjectIdTemplatesGetRequest

	// ProjectProjectIdTemplatesGetExecute executes the request
	//  @return []Template
	ProjectProjectIdTemplatesGetExecute(r ApiProjectProjectIdTemplatesGetRequest) ([]Template, *http.Response, error)

	/*
	ProjectProjectIdTemplatesPost create template

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdTemplatesPostRequest
	*/
	ProjectProjectIdTemplatesPost(ctx context.Context, projectId int32) ApiProjectProjectIdTemplatesPostRequest

	// ProjectProjectIdTemplatesPostExecute executes the request
	//  @return Template
	ProjectProjectIdTemplatesPostExecute(r ApiProjectProjectIdTemplatesPostRequest) (*Template, *http.Response, error)

	/*
	ProjectProjectIdTemplatesTemplateIdDelete Removes template

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param templateId template ID
	@return ApiProjectProjectIdTemplatesTemplateIdDeleteRequest
	*/
	ProjectProjectIdTemplatesTemplateIdDelete(ctx context.Context, projectId int32, templateId int32) ApiProjectProjectIdTemplatesTemplateIdDeleteRequest

	// ProjectProjectIdTemplatesTemplateIdDeleteExecute executes the request
	ProjectProjectIdTemplatesTemplateIdDeleteExecute(r ApiProjectProjectIdTemplatesTemplateIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdTemplatesTemplateIdGet Get template

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param templateId template ID
	@return ApiProjectProjectIdTemplatesTemplateIdGetRequest
	*/
	ProjectProjectIdTemplatesTemplateIdGet(ctx context.Context, projectId int32, templateId int32) ApiProjectProjectIdTemplatesTemplateIdGetRequest

	// ProjectProjectIdTemplatesTemplateIdGetExecute executes the request
	//  @return Template
	ProjectProjectIdTemplatesTemplateIdGetExecute(r ApiProjectProjectIdTemplatesTemplateIdGetRequest) (*Template, *http.Response, error)

	/*
	ProjectProjectIdTemplatesTemplateIdPut Updates template

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param templateId template ID
	@return ApiProjectProjectIdTemplatesTemplateIdPutRequest
	*/
	ProjectProjectIdTemplatesTemplateIdPut(ctx context.Context, projectId int32, templateId int32) ApiProjectProjectIdTemplatesTemplateIdPutRequest

	// ProjectProjectIdTemplatesTemplateIdPutExecute executes the request
	ProjectProjectIdTemplatesTemplateIdPutExecute(r ApiProjectProjectIdTemplatesTemplateIdPutRequest) (*http.Response, error)

	/*
	ProjectProjectIdUsersGet Get users linked to project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdUsersGetRequest
	*/
	ProjectProjectIdUsersGet(ctx context.Context, projectId int32) ApiProjectProjectIdUsersGetRequest

	// ProjectProjectIdUsersGetExecute executes the request
	//  @return []ProjectUser
	ProjectProjectIdUsersGetExecute(r ApiProjectProjectIdUsersGetRequest) ([]ProjectUser, *http.Response, error)

	/*
	ProjectProjectIdUsersPost Link user to project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdUsersPostRequest
	*/
	ProjectProjectIdUsersPost(ctx context.Context, projectId int32) ApiProjectProjectIdUsersPostRequest

	// ProjectProjectIdUsersPostExecute executes the request
	ProjectProjectIdUsersPostExecute(r ApiProjectProjectIdUsersPostRequest) (*http.Response, error)

	/*
	ProjectProjectIdUsersUserIdDelete Removes user from project

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param userId User ID
	@return ApiProjectProjectIdUsersUserIdDeleteRequest
	*/
	ProjectProjectIdUsersUserIdDelete(ctx context.Context, projectId int32, userId int32) ApiProjectProjectIdUsersUserIdDeleteRequest

	// ProjectProjectIdUsersUserIdDeleteExecute executes the request
	ProjectProjectIdUsersUserIdDeleteExecute(r ApiProjectProjectIdUsersUserIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdUsersUserIdPut Update user role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param userId User ID
	@return ApiProjectProjectIdUsersUserIdPutRequest
	*/
	ProjectProjectIdUsersUserIdPut(ctx context.Context, projectId int32, userId int32) ApiProjectProjectIdUsersUserIdPutRequest

	// ProjectProjectIdUsersUserIdPutExecute executes the request
	ProjectProjectIdUsersUserIdPutExecute(r ApiProjectProjectIdUsersUserIdPutRequest) (*http.Response, error)

	/*
	ProjectProjectIdViewsGet Get view

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdViewsGetRequest
	*/
	ProjectProjectIdViewsGet(ctx context.Context, projectId int32) ApiProjectProjectIdViewsGetRequest

	// ProjectProjectIdViewsGetExecute executes the request
	//  @return []View
	ProjectProjectIdViewsGetExecute(r ApiProjectProjectIdViewsGetRequest) ([]View, *http.Response, error)

	/*
	ProjectProjectIdViewsPost create view

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@return ApiProjectProjectIdViewsPostRequest
	*/
	ProjectProjectIdViewsPost(ctx context.Context, projectId int32) ApiProjectProjectIdViewsPostRequest

	// ProjectProjectIdViewsPostExecute executes the request
	//  @return View
	ProjectProjectIdViewsPostExecute(r ApiProjectProjectIdViewsPostRequest) (*View, *http.Response, error)

	/*
	ProjectProjectIdViewsViewIdDelete Removes view

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param viewId view ID
	@return ApiProjectProjectIdViewsViewIdDeleteRequest
	*/
	ProjectProjectIdViewsViewIdDelete(ctx context.Context, projectId int32, viewId int32) ApiProjectProjectIdViewsViewIdDeleteRequest

	// ProjectProjectIdViewsViewIdDeleteExecute executes the request
	ProjectProjectIdViewsViewIdDeleteExecute(r ApiProjectProjectIdViewsViewIdDeleteRequest) (*http.Response, error)

	/*
	ProjectProjectIdViewsViewIdGet Get view

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param viewId view ID
	@return ApiProjectProjectIdViewsViewIdGetRequest
	*/
	ProjectProjectIdViewsViewIdGet(ctx context.Context, projectId int32, viewId int32) ApiProjectProjectIdViewsViewIdGetRequest

	// ProjectProjectIdViewsViewIdGetExecute executes the request
	//  @return View
	ProjectProjectIdViewsViewIdGetExecute(r ApiProjectProjectIdViewsViewIdGetRequest) (*View, *http.Response, error)

	/*
	ProjectProjectIdViewsViewIdPut Updates view

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param projectId Project ID
	@param viewId view ID
	@return ApiProjectProjectIdViewsViewIdPutRequest
	*/
	ProjectProjectIdViewsViewIdPut(ctx context.Context, projectId int32, viewId int32) ApiProjectProjectIdViewsViewIdPutRequest

	// ProjectProjectIdViewsViewIdPutExecute executes the request
	ProjectProjectIdViewsViewIdPutExecute(r ApiProjectProjectIdViewsViewIdPutRequest) (*http.Response, error)
}

// ProjectAPIService ProjectAPI service
type ProjectAPIService service

type ApiProjectProjectIdBackupGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdBackupGetRequest) Execute() (*ProjectBackup, *http.Response, error) {
	return r.ApiService.ProjectProjectIdBackupGetExecute(r)
}

/*
ProjectProjectIdBackupGet Backup A Project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdBackupGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdBackupGet(ctx context.Context, projectId int32) ApiProjectProjectIdBackupGetRequest {
	return ApiProjectProjectIdBackupGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ProjectBackup
func (a *ProjectAPIService) ProjectProjectIdBackupGetExecute(r ApiProjectProjectIdBackupGetRequest) (*ProjectBackup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectBackup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdBackupGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/backup"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdDeleteExecute(r)
}

/*
ProjectProjectIdDelete Delete project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdDelete(ctx context.Context, projectId int32) ApiProjectProjectIdDeleteRequest {
	return ApiProjectProjectIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdDeleteExecute(r ApiProjectProjectIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	environmentId int32
}

func (r ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdEnvironmentEnvironmentIdDeleteExecute(r)
}

/*
ProjectProjectIdEnvironmentEnvironmentIdDelete Removes environment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param environmentId environment ID
 @return ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdEnvironmentEnvironmentIdDelete(ctx context.Context, projectId int32, environmentId int32) ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest {
	return ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		environmentId: environmentId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdEnvironmentEnvironmentIdDeleteExecute(r ApiProjectProjectIdEnvironmentEnvironmentIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdEnvironmentEnvironmentIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/environment/{environment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_id"+"}", url.PathEscape(parameterValueToString(r.environmentId, "environmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	environmentId int32
}

func (r ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest) Execute() (*Environment, *http.Response, error) {
	return r.ApiService.ProjectProjectIdEnvironmentEnvironmentIdGetExecute(r)
}

/*
ProjectProjectIdEnvironmentEnvironmentIdGet Get environment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param environmentId environment ID
 @return ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdEnvironmentEnvironmentIdGet(ctx context.Context, projectId int32, environmentId int32) ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest {
	return ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		environmentId: environmentId,
	}
}

// Execute executes the request
//  @return Environment
func (a *ProjectAPIService) ProjectProjectIdEnvironmentEnvironmentIdGetExecute(r ApiProjectProjectIdEnvironmentEnvironmentIdGetRequest) (*Environment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Environment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdEnvironmentEnvironmentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/environment/{environment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_id"+"}", url.PathEscape(parameterValueToString(r.environmentId, "environmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	environmentId int32
	environment *EnvironmentRequest
}

func (r ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest) Environment(environment EnvironmentRequest) ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest {
	r.environment = &environment
	return r
}

func (r ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdEnvironmentEnvironmentIdPutExecute(r)
}

/*
ProjectProjectIdEnvironmentEnvironmentIdPut Update environment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param environmentId environment ID
 @return ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdEnvironmentEnvironmentIdPut(ctx context.Context, projectId int32, environmentId int32) ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest {
	return ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		environmentId: environmentId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdEnvironmentEnvironmentIdPutExecute(r ApiProjectProjectIdEnvironmentEnvironmentIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdEnvironmentEnvironmentIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/environment/{environment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_id"+"}", url.PathEscape(parameterValueToString(r.environmentId, "environmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environment == nil {
		return nil, reportError("environment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.environment
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdEnvironmentGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	sort *string
	order *string
}

// sorting name
func (r ApiProjectProjectIdEnvironmentGetRequest) Sort(sort string) ApiProjectProjectIdEnvironmentGetRequest {
	r.sort = &sort
	return r
}

// ordering manner
func (r ApiProjectProjectIdEnvironmentGetRequest) Order(order string) ApiProjectProjectIdEnvironmentGetRequest {
	r.order = &order
	return r
}

func (r ApiProjectProjectIdEnvironmentGetRequest) Execute() ([]Environment, *http.Response, error) {
	return r.ApiService.ProjectProjectIdEnvironmentGetExecute(r)
}

/*
ProjectProjectIdEnvironmentGet Get environment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdEnvironmentGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdEnvironmentGet(ctx context.Context, projectId int32) ApiProjectProjectIdEnvironmentGetRequest {
	return ApiProjectProjectIdEnvironmentGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Environment
func (a *ProjectAPIService) ProjectProjectIdEnvironmentGetExecute(r ApiProjectProjectIdEnvironmentGetRequest) ([]Environment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Environment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdEnvironmentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/environment"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sort == nil {
		return localVarReturnValue, nil, reportError("sort is required and must be specified")
	}
	if r.order == nil {
		return localVarReturnValue, nil, reportError("order is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdEnvironmentPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	environment *EnvironmentRequest
}

func (r ApiProjectProjectIdEnvironmentPostRequest) Environment(environment EnvironmentRequest) ApiProjectProjectIdEnvironmentPostRequest {
	r.environment = &environment
	return r
}

func (r ApiProjectProjectIdEnvironmentPostRequest) Execute() (*Environment, *http.Response, error) {
	return r.ApiService.ProjectProjectIdEnvironmentPostExecute(r)
}

/*
ProjectProjectIdEnvironmentPost Add environment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdEnvironmentPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdEnvironmentPost(ctx context.Context, projectId int32) ApiProjectProjectIdEnvironmentPostRequest {
	return ApiProjectProjectIdEnvironmentPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Environment
func (a *ProjectAPIService) ProjectProjectIdEnvironmentPostExecute(r ApiProjectProjectIdEnvironmentPostRequest) (*Environment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Environment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdEnvironmentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/environment"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environment == nil {
		return localVarReturnValue, nil, reportError("environment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.environment
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdEventsGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdEventsGetRequest) Execute() ([]Event, *http.Response, error) {
	return r.ApiService.ProjectProjectIdEventsGetExecute(r)
}

/*
ProjectProjectIdEventsGet Get Events related to this project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdEventsGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdEventsGet(ctx context.Context, projectId int32) ApiProjectProjectIdEventsGetRequest {
	return ApiProjectProjectIdEventsGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Event
func (a *ProjectAPIService) ProjectProjectIdEventsGetExecute(r ApiProjectProjectIdEventsGetRequest) ([]Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdGetRequest) Execute() (*Project, *http.Response, error) {
	return r.ApiService.ProjectProjectIdGetExecute(r)
}

/*
ProjectProjectIdGet Fetch project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdGet(ctx context.Context, projectId int32) ApiProjectProjectIdGetRequest {
	return ApiProjectProjectIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Project
func (a *ProjectAPIService) ProjectProjectIdGetExecute(r ApiProjectProjectIdGetRequest) (*Project, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdIntegrationsGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdIntegrationsGetRequest) Execute() ([]Integration, *http.Response, error) {
	return r.ApiService.ProjectProjectIdIntegrationsGetExecute(r)
}

/*
ProjectProjectIdIntegrationsGet get all integrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdIntegrationsGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdIntegrationsGet(ctx context.Context, projectId int32) ApiProjectProjectIdIntegrationsGetRequest {
	return ApiProjectProjectIdIntegrationsGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Integration
func (a *ProjectAPIService) ProjectProjectIdIntegrationsGetExecute(r ApiProjectProjectIdIntegrationsGetRequest) ([]Integration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Integration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdIntegrationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/integrations"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	integrationId int32
}

func (r ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdIntegrationsIntegrationIdDeleteExecute(r)
}

/*
ProjectProjectIdIntegrationsIntegrationIdDelete Remove integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param integrationId integration ID
 @return ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdIntegrationsIntegrationIdDelete(ctx context.Context, projectId int32, integrationId int32) ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest {
	return ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		integrationId: integrationId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdIntegrationsIntegrationIdDeleteExecute(r ApiProjectProjectIdIntegrationsIntegrationIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdIntegrationsIntegrationIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/integrations/{integration_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integration_id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	integrationId int32
	integrationMatcher *IntegrationMatcher
}

func (r ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest) IntegrationMatcher(integrationMatcher IntegrationMatcher) ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest {
	r.integrationMatcher = &integrationMatcher
	return r
}

func (r ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdIntegrationsIntegrationIdMatchersPostExecute(r)
}

/*
ProjectProjectIdIntegrationsIntegrationIdMatchersPost Add Integration Matcher

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param integrationId integration ID
 @return ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdIntegrationsIntegrationIdMatchersPost(ctx context.Context, projectId int32, integrationId int32) ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest {
	return ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		integrationId: integrationId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdIntegrationsIntegrationIdMatchersPostExecute(r ApiProjectProjectIdIntegrationsIntegrationIdMatchersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdIntegrationsIntegrationIdMatchersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/integrations/{integration_id}/matchers"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integration_id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.integrationMatcher == nil {
		return nil, reportError("integrationMatcher is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.integrationMatcher
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdIntegrationsIntegrationIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	integrationId int32
	integration *IntegrationRequest
}

func (r ApiProjectProjectIdIntegrationsIntegrationIdPutRequest) Integration(integration IntegrationRequest) ApiProjectProjectIdIntegrationsIntegrationIdPutRequest {
	r.integration = &integration
	return r
}

func (r ApiProjectProjectIdIntegrationsIntegrationIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdIntegrationsIntegrationIdPutExecute(r)
}

/*
ProjectProjectIdIntegrationsIntegrationIdPut Update Integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param integrationId integration ID
 @return ApiProjectProjectIdIntegrationsIntegrationIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdIntegrationsIntegrationIdPut(ctx context.Context, projectId int32, integrationId int32) ApiProjectProjectIdIntegrationsIntegrationIdPutRequest {
	return ApiProjectProjectIdIntegrationsIntegrationIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		integrationId: integrationId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdIntegrationsIntegrationIdPutExecute(r ApiProjectProjectIdIntegrationsIntegrationIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdIntegrationsIntegrationIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/integrations/{integration_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integration_id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.integration == nil {
		return nil, reportError("integration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.integration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	integrationId int32
	integrationExtractedValue *IntegrationExtractValue
}

func (r ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest) IntegrationExtractedValue(integrationExtractedValue IntegrationExtractValue) ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest {
	r.integrationExtractedValue = &integrationExtractedValue
	return r
}

func (r ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdIntegrationsIntegrationIdValuesPostExecute(r)
}

/*
ProjectProjectIdIntegrationsIntegrationIdValuesPost Add Integration Extracted Value

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param integrationId integration ID
 @return ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdIntegrationsIntegrationIdValuesPost(ctx context.Context, projectId int32, integrationId int32) ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest {
	return ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		integrationId: integrationId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdIntegrationsIntegrationIdValuesPostExecute(r ApiProjectProjectIdIntegrationsIntegrationIdValuesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdIntegrationsIntegrationIdValuesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/integrations/{integration_id}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integration_id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.integrationExtractedValue == nil {
		return nil, reportError("integrationExtractedValue is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.integrationExtractedValue
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdIntegrationsPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	integration *IntegrationRequest
}

func (r ApiProjectProjectIdIntegrationsPostRequest) Integration(integration IntegrationRequest) ApiProjectProjectIdIntegrationsPostRequest {
	r.integration = &integration
	return r
}

func (r ApiProjectProjectIdIntegrationsPostRequest) Execute() (*Integration, *http.Response, error) {
	return r.ApiService.ProjectProjectIdIntegrationsPostExecute(r)
}

/*
ProjectProjectIdIntegrationsPost create a new integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdIntegrationsPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdIntegrationsPost(ctx context.Context, projectId int32) ApiProjectProjectIdIntegrationsPostRequest {
	return ApiProjectProjectIdIntegrationsPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Integration
func (a *ProjectAPIService) ProjectProjectIdIntegrationsPostExecute(r ApiProjectProjectIdIntegrationsPostRequest) (*Integration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Integration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdIntegrationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/integrations"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.integration == nil {
		return localVarReturnValue, nil, reportError("integration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.integration
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdInventoryGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	sort *string
	order *string
}

// sorting name
func (r ApiProjectProjectIdInventoryGetRequest) Sort(sort string) ApiProjectProjectIdInventoryGetRequest {
	r.sort = &sort
	return r
}

// ordering manner
func (r ApiProjectProjectIdInventoryGetRequest) Order(order string) ApiProjectProjectIdInventoryGetRequest {
	r.order = &order
	return r
}

func (r ApiProjectProjectIdInventoryGetRequest) Execute() ([]Inventory, *http.Response, error) {
	return r.ApiService.ProjectProjectIdInventoryGetExecute(r)
}

/*
ProjectProjectIdInventoryGet Get inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdInventoryGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdInventoryGet(ctx context.Context, projectId int32) ApiProjectProjectIdInventoryGetRequest {
	return ApiProjectProjectIdInventoryGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Inventory
func (a *ProjectAPIService) ProjectProjectIdInventoryGetExecute(r ApiProjectProjectIdInventoryGetRequest) ([]Inventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Inventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdInventoryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/inventory"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sort == nil {
		return localVarReturnValue, nil, reportError("sort is required and must be specified")
	}
	if r.order == nil {
		return localVarReturnValue, nil, reportError("order is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdInventoryInventoryIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	inventoryId int32
}

func (r ApiProjectProjectIdInventoryInventoryIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdInventoryInventoryIdDeleteExecute(r)
}

/*
ProjectProjectIdInventoryInventoryIdDelete Removes inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param inventoryId inventory ID
 @return ApiProjectProjectIdInventoryInventoryIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdInventoryInventoryIdDelete(ctx context.Context, projectId int32, inventoryId int32) ApiProjectProjectIdInventoryInventoryIdDeleteRequest {
	return ApiProjectProjectIdInventoryInventoryIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		inventoryId: inventoryId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdInventoryInventoryIdDeleteExecute(r ApiProjectProjectIdInventoryInventoryIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdInventoryInventoryIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/inventory/{inventory_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"inventory_id"+"}", url.PathEscape(parameterValueToString(r.inventoryId, "inventoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdInventoryInventoryIdGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	inventoryId int32
}

func (r ApiProjectProjectIdInventoryInventoryIdGetRequest) Execute() (*Inventory, *http.Response, error) {
	return r.ApiService.ProjectProjectIdInventoryInventoryIdGetExecute(r)
}

/*
ProjectProjectIdInventoryInventoryIdGet Get inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param inventoryId inventory ID
 @return ApiProjectProjectIdInventoryInventoryIdGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdInventoryInventoryIdGet(ctx context.Context, projectId int32, inventoryId int32) ApiProjectProjectIdInventoryInventoryIdGetRequest {
	return ApiProjectProjectIdInventoryInventoryIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		inventoryId: inventoryId,
	}
}

// Execute executes the request
//  @return Inventory
func (a *ProjectAPIService) ProjectProjectIdInventoryInventoryIdGetExecute(r ApiProjectProjectIdInventoryInventoryIdGetRequest) (*Inventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Inventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdInventoryInventoryIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/inventory/{inventory_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"inventory_id"+"}", url.PathEscape(parameterValueToString(r.inventoryId, "inventoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdInventoryInventoryIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	inventoryId int32
	inventory *InventoryRequest
}

func (r ApiProjectProjectIdInventoryInventoryIdPutRequest) Inventory(inventory InventoryRequest) ApiProjectProjectIdInventoryInventoryIdPutRequest {
	r.inventory = &inventory
	return r
}

func (r ApiProjectProjectIdInventoryInventoryIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdInventoryInventoryIdPutExecute(r)
}

/*
ProjectProjectIdInventoryInventoryIdPut Updates inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param inventoryId inventory ID
 @return ApiProjectProjectIdInventoryInventoryIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdInventoryInventoryIdPut(ctx context.Context, projectId int32, inventoryId int32) ApiProjectProjectIdInventoryInventoryIdPutRequest {
	return ApiProjectProjectIdInventoryInventoryIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		inventoryId: inventoryId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdInventoryInventoryIdPutExecute(r ApiProjectProjectIdInventoryInventoryIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdInventoryInventoryIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/inventory/{inventory_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"inventory_id"+"}", url.PathEscape(parameterValueToString(r.inventoryId, "inventoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventory == nil {
		return nil, reportError("inventory is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventory
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdInventoryPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	inventory *InventoryRequest
}

func (r ApiProjectProjectIdInventoryPostRequest) Inventory(inventory InventoryRequest) ApiProjectProjectIdInventoryPostRequest {
	r.inventory = &inventory
	return r
}

func (r ApiProjectProjectIdInventoryPostRequest) Execute() (*Inventory, *http.Response, error) {
	return r.ApiService.ProjectProjectIdInventoryPostExecute(r)
}

/*
ProjectProjectIdInventoryPost create inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdInventoryPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdInventoryPost(ctx context.Context, projectId int32) ApiProjectProjectIdInventoryPostRequest {
	return ApiProjectProjectIdInventoryPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Inventory
func (a *ProjectAPIService) ProjectProjectIdInventoryPostExecute(r ApiProjectProjectIdInventoryPostRequest) (*Inventory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Inventory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdInventoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/inventory"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inventory == nil {
		return localVarReturnValue, nil, reportError("inventory is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inventory
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdKeysGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	sort *string
	order *string
	keyType *string
}

// sorting name
func (r ApiProjectProjectIdKeysGetRequest) Sort(sort string) ApiProjectProjectIdKeysGetRequest {
	r.sort = &sort
	return r
}

// ordering manner
func (r ApiProjectProjectIdKeysGetRequest) Order(order string) ApiProjectProjectIdKeysGetRequest {
	r.order = &order
	return r
}

// Filter by key type
func (r ApiProjectProjectIdKeysGetRequest) KeyType(keyType string) ApiProjectProjectIdKeysGetRequest {
	r.keyType = &keyType
	return r
}

func (r ApiProjectProjectIdKeysGetRequest) Execute() ([]AccessKey, *http.Response, error) {
	return r.ApiService.ProjectProjectIdKeysGetExecute(r)
}

/*
ProjectProjectIdKeysGet Get access keys linked to project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdKeysGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdKeysGet(ctx context.Context, projectId int32) ApiProjectProjectIdKeysGetRequest {
	return ApiProjectProjectIdKeysGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []AccessKey
func (a *ProjectAPIService) ProjectProjectIdKeysGetExecute(r ApiProjectProjectIdKeysGetRequest) ([]AccessKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AccessKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdKeysGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sort == nil {
		return localVarReturnValue, nil, reportError("sort is required and must be specified")
	}
	if r.order == nil {
		return localVarReturnValue, nil, reportError("order is required and must be specified")
	}

	if r.keyType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Key type", r.keyType, "", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdKeysKeyIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	keyId int32
}

func (r ApiProjectProjectIdKeysKeyIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdKeysKeyIdDeleteExecute(r)
}

/*
ProjectProjectIdKeysKeyIdDelete Removes access key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param keyId key ID
 @return ApiProjectProjectIdKeysKeyIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdKeysKeyIdDelete(ctx context.Context, projectId int32, keyId int32) ApiProjectProjectIdKeysKeyIdDeleteRequest {
	return ApiProjectProjectIdKeysKeyIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		keyId: keyId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdKeysKeyIdDeleteExecute(r ApiProjectProjectIdKeysKeyIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdKeysKeyIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/keys/{key_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key_id"+"}", url.PathEscape(parameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdKeysKeyIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	keyId int32
	accessKey *AccessKeyRequest
}

func (r ApiProjectProjectIdKeysKeyIdPutRequest) AccessKey(accessKey AccessKeyRequest) ApiProjectProjectIdKeysKeyIdPutRequest {
	r.accessKey = &accessKey
	return r
}

func (r ApiProjectProjectIdKeysKeyIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdKeysKeyIdPutExecute(r)
}

/*
ProjectProjectIdKeysKeyIdPut Updates access key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param keyId key ID
 @return ApiProjectProjectIdKeysKeyIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdKeysKeyIdPut(ctx context.Context, projectId int32, keyId int32) ApiProjectProjectIdKeysKeyIdPutRequest {
	return ApiProjectProjectIdKeysKeyIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		keyId: keyId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdKeysKeyIdPutExecute(r ApiProjectProjectIdKeysKeyIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdKeysKeyIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/keys/{key_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"key_id"+"}", url.PathEscape(parameterValueToString(r.keyId, "keyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accessKey == nil {
		return nil, reportError("accessKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accessKey
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdKeysPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	accessKey *AccessKeyRequest
}

func (r ApiProjectProjectIdKeysPostRequest) AccessKey(accessKey AccessKeyRequest) ApiProjectProjectIdKeysPostRequest {
	r.accessKey = &accessKey
	return r
}

func (r ApiProjectProjectIdKeysPostRequest) Execute() (*AccessKey, *http.Response, error) {
	return r.ApiService.ProjectProjectIdKeysPostExecute(r)
}

/*
ProjectProjectIdKeysPost Add access key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdKeysPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdKeysPost(ctx context.Context, projectId int32) ApiProjectProjectIdKeysPostRequest {
	return ApiProjectProjectIdKeysPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return AccessKey
func (a *ProjectAPIService) ProjectProjectIdKeysPostExecute(r ApiProjectProjectIdKeysPostRequest) (*AccessKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdKeysPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/keys"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accessKey == nil {
		return localVarReturnValue, nil, reportError("accessKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accessKey
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	project *ProjectProjectIdPutRequest
}

func (r ApiProjectProjectIdPutRequest) Project(project ProjectProjectIdPutRequest) ApiProjectProjectIdPutRequest {
	r.project = &project
	return r
}

func (r ApiProjectProjectIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdPutExecute(r)
}

/*
ProjectProjectIdPut Update project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdPut(ctx context.Context, projectId int32) ApiProjectProjectIdPutRequest {
	return ApiProjectProjectIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdPutExecute(r ApiProjectProjectIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.project == nil {
		return nil, reportError("project is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.project
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdRepositoriesGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	sort *string
	order *string
}

// sorting name
func (r ApiProjectProjectIdRepositoriesGetRequest) Sort(sort string) ApiProjectProjectIdRepositoriesGetRequest {
	r.sort = &sort
	return r
}

// ordering manner
func (r ApiProjectProjectIdRepositoriesGetRequest) Order(order string) ApiProjectProjectIdRepositoriesGetRequest {
	r.order = &order
	return r
}

func (r ApiProjectProjectIdRepositoriesGetRequest) Execute() ([]Repository, *http.Response, error) {
	return r.ApiService.ProjectProjectIdRepositoriesGetExecute(r)
}

/*
ProjectProjectIdRepositoriesGet Get repositories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdRepositoriesGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdRepositoriesGet(ctx context.Context, projectId int32) ApiProjectProjectIdRepositoriesGetRequest {
	return ApiProjectProjectIdRepositoriesGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Repository
func (a *ProjectAPIService) ProjectProjectIdRepositoriesGetExecute(r ApiProjectProjectIdRepositoriesGetRequest) ([]Repository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdRepositoriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sort == nil {
		return localVarReturnValue, nil, reportError("sort is required and must be specified")
	}
	if r.order == nil {
		return localVarReturnValue, nil, reportError("order is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdRepositoriesPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	repository *RepositoryRequest
}

func (r ApiProjectProjectIdRepositoriesPostRequest) Repository(repository RepositoryRequest) ApiProjectProjectIdRepositoriesPostRequest {
	r.repository = &repository
	return r
}

func (r ApiProjectProjectIdRepositoriesPostRequest) Execute() (*Repository, *http.Response, error) {
	return r.ApiService.ProjectProjectIdRepositoriesPostExecute(r)
}

/*
ProjectProjectIdRepositoriesPost Add repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdRepositoriesPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdRepositoriesPost(ctx context.Context, projectId int32) ApiProjectProjectIdRepositoriesPostRequest {
	return ApiProjectProjectIdRepositoriesPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Repository
func (a *ProjectAPIService) ProjectProjectIdRepositoriesPostExecute(r ApiProjectProjectIdRepositoriesPostRequest) (*Repository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdRepositoriesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.repository == nil {
		return localVarReturnValue, nil, reportError("repository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.repository
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	repositoryId int32
}

func (r ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdRepositoriesRepositoryIdDeleteExecute(r)
}

/*
ProjectProjectIdRepositoriesRepositoryIdDelete Removes repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param repositoryId repository ID
 @return ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdRepositoriesRepositoryIdDelete(ctx context.Context, projectId int32, repositoryId int32) ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest {
	return ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdRepositoriesRepositoryIdDeleteExecute(r ApiProjectProjectIdRepositoriesRepositoryIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdRepositoriesRepositoryIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterValueToString(r.repositoryId, "repositoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdRepositoriesRepositoryIdGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	repositoryId int32
}

func (r ApiProjectProjectIdRepositoriesRepositoryIdGetRequest) Execute() (*Repository, *http.Response, error) {
	return r.ApiService.ProjectProjectIdRepositoriesRepositoryIdGetExecute(r)
}

/*
ProjectProjectIdRepositoriesRepositoryIdGet Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param repositoryId repository ID
 @return ApiProjectProjectIdRepositoriesRepositoryIdGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdRepositoriesRepositoryIdGet(ctx context.Context, projectId int32, repositoryId int32) ApiProjectProjectIdRepositoriesRepositoryIdGetRequest {
	return ApiProjectProjectIdRepositoriesRepositoryIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
//  @return Repository
func (a *ProjectAPIService) ProjectProjectIdRepositoriesRepositoryIdGetExecute(r ApiProjectProjectIdRepositoriesRepositoryIdGetRequest) (*Repository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdRepositoriesRepositoryIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterValueToString(r.repositoryId, "repositoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdRepositoriesRepositoryIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	repositoryId int32
	repository *RepositoryRequest
}

func (r ApiProjectProjectIdRepositoriesRepositoryIdPutRequest) Repository(repository RepositoryRequest) ApiProjectProjectIdRepositoriesRepositoryIdPutRequest {
	r.repository = &repository
	return r
}

func (r ApiProjectProjectIdRepositoriesRepositoryIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdRepositoriesRepositoryIdPutExecute(r)
}

/*
ProjectProjectIdRepositoriesRepositoryIdPut Updates repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param repositoryId repository ID
 @return ApiProjectProjectIdRepositoriesRepositoryIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdRepositoriesRepositoryIdPut(ctx context.Context, projectId int32, repositoryId int32) ApiProjectProjectIdRepositoriesRepositoryIdPutRequest {
	return ApiProjectProjectIdRepositoriesRepositoryIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		repositoryId: repositoryId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdRepositoriesRepositoryIdPutExecute(r ApiProjectProjectIdRepositoriesRepositoryIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdRepositoriesRepositoryIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/repositories/{repository_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository_id"+"}", url.PathEscape(parameterValueToString(r.repositoryId, "repositoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.repository == nil {
		return nil, reportError("repository is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.repository
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdRoleGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdRoleGetRequest) Execute() (*ProjectProjectIdRoleGet200Response, *http.Response, error) {
	return r.ApiService.ProjectProjectIdRoleGetExecute(r)
}

/*
ProjectProjectIdRoleGet Fetch permissions of the current user for project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdRoleGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdRoleGet(ctx context.Context, projectId int32) ApiProjectProjectIdRoleGetRequest {
	return ApiProjectProjectIdRoleGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ProjectProjectIdRoleGet200Response
func (a *ProjectAPIService) ProjectProjectIdRoleGetExecute(r ApiProjectProjectIdRoleGetRequest) (*ProjectProjectIdRoleGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectProjectIdRoleGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdRoleGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/role"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTasksGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdTasksGetRequest) Execute() ([]Task, *http.Response, error) {
	return r.ApiService.ProjectProjectIdTasksGetExecute(r)
}

/*
ProjectProjectIdTasksGet Get Tasks related to current project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdTasksGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTasksGet(ctx context.Context, projectId int32) ApiProjectProjectIdTasksGetRequest {
	return ApiProjectProjectIdTasksGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Task
func (a *ProjectAPIService) ProjectProjectIdTasksGetExecute(r ApiProjectProjectIdTasksGetRequest) ([]Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTasksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTasksLastGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdTasksLastGetRequest) Execute() ([]Task, *http.Response, error) {
	return r.ApiService.ProjectProjectIdTasksLastGetExecute(r)
}

/*
ProjectProjectIdTasksLastGet Get last 200 Tasks related to current project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdTasksLastGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTasksLastGet(ctx context.Context, projectId int32) ApiProjectProjectIdTasksLastGetRequest {
	return ApiProjectProjectIdTasksLastGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Task
func (a *ProjectAPIService) ProjectProjectIdTasksLastGetExecute(r ApiProjectProjectIdTasksLastGetRequest) ([]Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTasksLastGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/tasks/last"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTasksPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	task *ProjectProjectIdTasksPostRequest
}

func (r ApiProjectProjectIdTasksPostRequest) Task(task ProjectProjectIdTasksPostRequest) ApiProjectProjectIdTasksPostRequest {
	r.task = &task
	return r
}

func (r ApiProjectProjectIdTasksPostRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.ProjectProjectIdTasksPostExecute(r)
}

/*
ProjectProjectIdTasksPost Starts a job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdTasksPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTasksPost(ctx context.Context, projectId int32) ApiProjectProjectIdTasksPostRequest {
	return ApiProjectProjectIdTasksPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Task
func (a *ProjectAPIService) ProjectProjectIdTasksPostExecute(r ApiProjectProjectIdTasksPostRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTasksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.task == nil {
		return localVarReturnValue, nil, reportError("task is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.task
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTasksTaskIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	taskId int32
}

func (r ApiProjectProjectIdTasksTaskIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdTasksTaskIdDeleteExecute(r)
}

/*
ProjectProjectIdTasksTaskIdDelete Deletes task (including output)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param taskId task ID
 @return ApiProjectProjectIdTasksTaskIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTasksTaskIdDelete(ctx context.Context, projectId int32, taskId int32) ApiProjectProjectIdTasksTaskIdDeleteRequest {
	return ApiProjectProjectIdTasksTaskIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdTasksTaskIdDeleteExecute(r ApiProjectProjectIdTasksTaskIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTasksTaskIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdTasksTaskIdGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	taskId int32
}

func (r ApiProjectProjectIdTasksTaskIdGetRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.ProjectProjectIdTasksTaskIdGetExecute(r)
}

/*
ProjectProjectIdTasksTaskIdGet Get a single task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param taskId task ID
 @return ApiProjectProjectIdTasksTaskIdGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTasksTaskIdGet(ctx context.Context, projectId int32, taskId int32) ApiProjectProjectIdTasksTaskIdGetRequest {
	return ApiProjectProjectIdTasksTaskIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return Task
func (a *ProjectAPIService) ProjectProjectIdTasksTaskIdGetExecute(r ApiProjectProjectIdTasksTaskIdGetRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTasksTaskIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTasksTaskIdOutputGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	taskId int32
}

func (r ApiProjectProjectIdTasksTaskIdOutputGetRequest) Execute() ([]TaskOutput, *http.Response, error) {
	return r.ApiService.ProjectProjectIdTasksTaskIdOutputGetExecute(r)
}

/*
ProjectProjectIdTasksTaskIdOutputGet Get task output

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param taskId task ID
 @return ApiProjectProjectIdTasksTaskIdOutputGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTasksTaskIdOutputGet(ctx context.Context, projectId int32, taskId int32) ApiProjectProjectIdTasksTaskIdOutputGetRequest {
	return ApiProjectProjectIdTasksTaskIdOutputGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return []TaskOutput
func (a *ProjectAPIService) ProjectProjectIdTasksTaskIdOutputGetExecute(r ApiProjectProjectIdTasksTaskIdOutputGetRequest) ([]TaskOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaskOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTasksTaskIdOutputGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/tasks/{task_id}/output"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTasksTaskIdStopPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	taskId int32
}

func (r ApiProjectProjectIdTasksTaskIdStopPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdTasksTaskIdStopPostExecute(r)
}

/*
ProjectProjectIdTasksTaskIdStopPost Stop a job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param taskId task ID
 @return ApiProjectProjectIdTasksTaskIdStopPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTasksTaskIdStopPost(ctx context.Context, projectId int32, taskId int32) ApiProjectProjectIdTasksTaskIdStopPostRequest {
	return ApiProjectProjectIdTasksTaskIdStopPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdTasksTaskIdStopPostExecute(r ApiProjectProjectIdTasksTaskIdStopPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTasksTaskIdStopPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/tasks/{task_id}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdTemplatesGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	sort *string
	order *string
}

// sorting name
func (r ApiProjectProjectIdTemplatesGetRequest) Sort(sort string) ApiProjectProjectIdTemplatesGetRequest {
	r.sort = &sort
	return r
}

// ordering manner
func (r ApiProjectProjectIdTemplatesGetRequest) Order(order string) ApiProjectProjectIdTemplatesGetRequest {
	r.order = &order
	return r
}

func (r ApiProjectProjectIdTemplatesGetRequest) Execute() ([]Template, *http.Response, error) {
	return r.ApiService.ProjectProjectIdTemplatesGetExecute(r)
}

/*
ProjectProjectIdTemplatesGet Get template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdTemplatesGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTemplatesGet(ctx context.Context, projectId int32) ApiProjectProjectIdTemplatesGetRequest {
	return ApiProjectProjectIdTemplatesGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []Template
func (a *ProjectAPIService) ProjectProjectIdTemplatesGetExecute(r ApiProjectProjectIdTemplatesGetRequest) ([]Template, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTemplatesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sort == nil {
		return localVarReturnValue, nil, reportError("sort is required and must be specified")
	}
	if r.order == nil {
		return localVarReturnValue, nil, reportError("order is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTemplatesPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	template *TemplateRequest
}

func (r ApiProjectProjectIdTemplatesPostRequest) Template(template TemplateRequest) ApiProjectProjectIdTemplatesPostRequest {
	r.template = &template
	return r
}

func (r ApiProjectProjectIdTemplatesPostRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.ProjectProjectIdTemplatesPostExecute(r)
}

/*
ProjectProjectIdTemplatesPost create template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdTemplatesPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTemplatesPost(ctx context.Context, projectId int32) ApiProjectProjectIdTemplatesPostRequest {
	return ApiProjectProjectIdTemplatesPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Template
func (a *ProjectAPIService) ProjectProjectIdTemplatesPostExecute(r ApiProjectProjectIdTemplatesPostRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTemplatesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.template == nil {
		return localVarReturnValue, nil, reportError("template is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.template
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTemplatesTemplateIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	templateId int32
}

func (r ApiProjectProjectIdTemplatesTemplateIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdTemplatesTemplateIdDeleteExecute(r)
}

/*
ProjectProjectIdTemplatesTemplateIdDelete Removes template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param templateId template ID
 @return ApiProjectProjectIdTemplatesTemplateIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTemplatesTemplateIdDelete(ctx context.Context, projectId int32, templateId int32) ApiProjectProjectIdTemplatesTemplateIdDeleteRequest {
	return ApiProjectProjectIdTemplatesTemplateIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdTemplatesTemplateIdDeleteExecute(r ApiProjectProjectIdTemplatesTemplateIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTemplatesTemplateIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdTemplatesTemplateIdGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	templateId int32
}

func (r ApiProjectProjectIdTemplatesTemplateIdGetRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.ProjectProjectIdTemplatesTemplateIdGetExecute(r)
}

/*
ProjectProjectIdTemplatesTemplateIdGet Get template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param templateId template ID
 @return ApiProjectProjectIdTemplatesTemplateIdGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTemplatesTemplateIdGet(ctx context.Context, projectId int32, templateId int32) ApiProjectProjectIdTemplatesTemplateIdGetRequest {
	return ApiProjectProjectIdTemplatesTemplateIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return Template
func (a *ProjectAPIService) ProjectProjectIdTemplatesTemplateIdGetExecute(r ApiProjectProjectIdTemplatesTemplateIdGetRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTemplatesTemplateIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdTemplatesTemplateIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	templateId int32
	template *TemplateRequest
}

func (r ApiProjectProjectIdTemplatesTemplateIdPutRequest) Template(template TemplateRequest) ApiProjectProjectIdTemplatesTemplateIdPutRequest {
	r.template = &template
	return r
}

func (r ApiProjectProjectIdTemplatesTemplateIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdTemplatesTemplateIdPutExecute(r)
}

/*
ProjectProjectIdTemplatesTemplateIdPut Updates template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param templateId template ID
 @return ApiProjectProjectIdTemplatesTemplateIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdTemplatesTemplateIdPut(ctx context.Context, projectId int32, templateId int32) ApiProjectProjectIdTemplatesTemplateIdPutRequest {
	return ApiProjectProjectIdTemplatesTemplateIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdTemplatesTemplateIdPutExecute(r ApiProjectProjectIdTemplatesTemplateIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdTemplatesTemplateIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.template == nil {
		return nil, reportError("template is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.template
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdUsersGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	sort *string
	order *string
}

// sorting name
func (r ApiProjectProjectIdUsersGetRequest) Sort(sort string) ApiProjectProjectIdUsersGetRequest {
	r.sort = &sort
	return r
}

// ordering manner
func (r ApiProjectProjectIdUsersGetRequest) Order(order string) ApiProjectProjectIdUsersGetRequest {
	r.order = &order
	return r
}

func (r ApiProjectProjectIdUsersGetRequest) Execute() ([]ProjectUser, *http.Response, error) {
	return r.ApiService.ProjectProjectIdUsersGetExecute(r)
}

/*
ProjectProjectIdUsersGet Get users linked to project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdUsersGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdUsersGet(ctx context.Context, projectId int32) ApiProjectProjectIdUsersGetRequest {
	return ApiProjectProjectIdUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []ProjectUser
func (a *ProjectAPIService) ProjectProjectIdUsersGetExecute(r ApiProjectProjectIdUsersGetRequest) ([]ProjectUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProjectUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sort == nil {
		return localVarReturnValue, nil, reportError("sort is required and must be specified")
	}
	if r.order == nil {
		return localVarReturnValue, nil, reportError("order is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdUsersPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	user *ProjectProjectIdUsersPostRequest
}

func (r ApiProjectProjectIdUsersPostRequest) User(user ProjectProjectIdUsersPostRequest) ApiProjectProjectIdUsersPostRequest {
	r.user = &user
	return r
}

func (r ApiProjectProjectIdUsersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdUsersPostExecute(r)
}

/*
ProjectProjectIdUsersPost Link user to project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdUsersPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdUsersPost(ctx context.Context, projectId int32) ApiProjectProjectIdUsersPostRequest {
	return ApiProjectProjectIdUsersPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdUsersPostExecute(r ApiProjectProjectIdUsersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdUsersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.user == nil {
		return nil, reportError("user is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.user
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdUsersUserIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	userId int32
}

func (r ApiProjectProjectIdUsersUserIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdUsersUserIdDeleteExecute(r)
}

/*
ProjectProjectIdUsersUserIdDelete Removes user from project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param userId User ID
 @return ApiProjectProjectIdUsersUserIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdUsersUserIdDelete(ctx context.Context, projectId int32, userId int32) ApiProjectProjectIdUsersUserIdDeleteRequest {
	return ApiProjectProjectIdUsersUserIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		userId: userId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdUsersUserIdDeleteExecute(r ApiProjectProjectIdUsersUserIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdUsersUserIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdUsersUserIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	userId int32
	projectUser *ProjectProjectIdUsersUserIdPutRequest
}

func (r ApiProjectProjectIdUsersUserIdPutRequest) ProjectUser(projectUser ProjectProjectIdUsersUserIdPutRequest) ApiProjectProjectIdUsersUserIdPutRequest {
	r.projectUser = &projectUser
	return r
}

func (r ApiProjectProjectIdUsersUserIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdUsersUserIdPutExecute(r)
}

/*
ProjectProjectIdUsersUserIdPut Update user role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param userId User ID
 @return ApiProjectProjectIdUsersUserIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdUsersUserIdPut(ctx context.Context, projectId int32, userId int32) ApiProjectProjectIdUsersUserIdPutRequest {
	return ApiProjectProjectIdUsersUserIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		userId: userId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdUsersUserIdPutExecute(r ApiProjectProjectIdUsersUserIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdUsersUserIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.projectUser == nil {
		return nil, reportError("projectUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.projectUser
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdViewsGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
}

func (r ApiProjectProjectIdViewsGetRequest) Execute() ([]View, *http.Response, error) {
	return r.ApiService.ProjectProjectIdViewsGetExecute(r)
}

/*
ProjectProjectIdViewsGet Get view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdViewsGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdViewsGet(ctx context.Context, projectId int32) ApiProjectProjectIdViewsGetRequest {
	return ApiProjectProjectIdViewsGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []View
func (a *ProjectAPIService) ProjectProjectIdViewsGetExecute(r ApiProjectProjectIdViewsGetRequest) ([]View, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []View
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdViewsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/views"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdViewsPostRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	view *ViewRequest
}

func (r ApiProjectProjectIdViewsPostRequest) View(view ViewRequest) ApiProjectProjectIdViewsPostRequest {
	r.view = &view
	return r
}

func (r ApiProjectProjectIdViewsPostRequest) Execute() (*View, *http.Response, error) {
	return r.ApiService.ProjectProjectIdViewsPostExecute(r)
}

/*
ProjectProjectIdViewsPost create view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @return ApiProjectProjectIdViewsPostRequest
*/
func (a *ProjectAPIService) ProjectProjectIdViewsPost(ctx context.Context, projectId int32) ApiProjectProjectIdViewsPostRequest {
	return ApiProjectProjectIdViewsPostRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return View
func (a *ProjectAPIService) ProjectProjectIdViewsPostExecute(r ApiProjectProjectIdViewsPostRequest) (*View, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *View
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdViewsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/views"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.view == nil {
		return localVarReturnValue, nil, reportError("view is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.view
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdViewsViewIdDeleteRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	viewId int32
}

func (r ApiProjectProjectIdViewsViewIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdViewsViewIdDeleteExecute(r)
}

/*
ProjectProjectIdViewsViewIdDelete Removes view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param viewId view ID
 @return ApiProjectProjectIdViewsViewIdDeleteRequest
*/
func (a *ProjectAPIService) ProjectProjectIdViewsViewIdDelete(ctx context.Context, projectId int32, viewId int32) ApiProjectProjectIdViewsViewIdDeleteRequest {
	return ApiProjectProjectIdViewsViewIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		viewId: viewId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdViewsViewIdDeleteExecute(r ApiProjectProjectIdViewsViewIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdViewsViewIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/views/{view_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"view_id"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProjectProjectIdViewsViewIdGetRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	viewId int32
}

func (r ApiProjectProjectIdViewsViewIdGetRequest) Execute() (*View, *http.Response, error) {
	return r.ApiService.ProjectProjectIdViewsViewIdGetExecute(r)
}

/*
ProjectProjectIdViewsViewIdGet Get view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param viewId view ID
 @return ApiProjectProjectIdViewsViewIdGetRequest
*/
func (a *ProjectAPIService) ProjectProjectIdViewsViewIdGet(ctx context.Context, projectId int32, viewId int32) ApiProjectProjectIdViewsViewIdGetRequest {
	return ApiProjectProjectIdViewsViewIdGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		viewId: viewId,
	}
}

// Execute executes the request
//  @return View
func (a *ProjectAPIService) ProjectProjectIdViewsViewIdGetExecute(r ApiProjectProjectIdViewsViewIdGetRequest) (*View, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *View
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdViewsViewIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/views/{view_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"view_id"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectProjectIdViewsViewIdPutRequest struct {
	ctx context.Context
	ApiService ProjectAPI
	projectId int32
	viewId int32
	view *ViewRequest
}

func (r ApiProjectProjectIdViewsViewIdPutRequest) View(view ViewRequest) ApiProjectProjectIdViewsViewIdPutRequest {
	r.view = &view
	return r
}

func (r ApiProjectProjectIdViewsViewIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProjectProjectIdViewsViewIdPutExecute(r)
}

/*
ProjectProjectIdViewsViewIdPut Updates view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID
 @param viewId view ID
 @return ApiProjectProjectIdViewsViewIdPutRequest
*/
func (a *ProjectAPIService) ProjectProjectIdViewsViewIdPut(ctx context.Context, projectId int32, viewId int32) ApiProjectProjectIdViewsViewIdPutRequest {
	return ApiProjectProjectIdViewsViewIdPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		viewId: viewId,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ProjectProjectIdViewsViewIdPutExecute(r ApiProjectProjectIdViewsViewIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ProjectProjectIdViewsViewIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project_id}/views/{view_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"view_id"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.view == nil {
		return nil, reportError("view is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.view
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["cookie"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Cookie"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
